import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/lodash.memoize/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.memoize/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    module.exports = memoize2;
  }
});

// node_modules/@pollinations/react/src/hooks/usePollinationsImage.js
var import_react = __toESM(require_react(), 1);
var usePollinationsImage = (prompt, options = {}) => {
  const { width = 1024, height = 1024, model = "flux", seed = 42, nologo = true, enhance = false } = options;
  const imageUrl = (0, import_react.useMemo)(() => {
    const params = new URLSearchParams({ width, height, model, seed, nologo, enhance });
    return `https://pollinations.ai/p/${encodeURIComponent(prompt)}?${params.toString()}`;
  }, [prompt, width, height, model, seed, nologo, enhance]);
  return imageUrl;
};
var usePollinationsImage_default = usePollinationsImage;

// node_modules/@pollinations/react/src/hooks/usePollinationsText.js
var import_react2 = __toESM(require_react(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var usePollinationsText = (prompt, options = {}) => {
  const { seed = 42, systemPrompt, model, jsonMode = false, loadNull = false } = options;
  const [text, setText] = (0, import_react2.useState)(null);
  const currentFetchRef = (0, import_react2.useRef)(Promise.resolve());
  const requestBody = (0, import_react2.useMemo)(() => {
    const messages = systemPrompt ? [{ role: "system", content: systemPrompt }] : [];
    messages.push({ role: "user", content: prompt });
    return { messages, seed, model, jsonMode };
  }, [prompt, systemPrompt, seed, model, jsonMode]);
  const fetchText = (0, import_react2.useCallback)(() => {
    currentFetchRef.current = currentFetchRef.current.then(() => memoizedFetchPollinationsText(requestBody)).then((cleanedData) => {
      setText(cleanedData);
    }).catch((error) => {
      console.error("Error in usePollinationsText:", error);
      setText(`An error occurred while generating text: ${error.message}. Please try again.`);
    });
  }, [requestBody]);
  (0, import_react2.useEffect)(() => {
    if (prompt === null) return;
    if (loadNull) setText(null);
    fetchText();
  }, [fetchText, loadNull, prompt]);
  return text;
};
var fetchPollinationsText = async (requestBody) => {
  try {
    const response = await fetch("https://text.pollinations.ai/", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.text();
    return requestBody.jsonMode ? JSON.parse(data) : cleanMarkdown(data);
  } catch (error) {
    console.error("Error fetching text from Pollinations API:", error);
    throw error;
  }
};
var memoizedFetchPollinationsText = (0, import_lodash.default)(fetchPollinationsText, JSON.stringify);
var cleanMarkdown = (data) => {
  const match = data.match(/```([\s\S]*?)```/);
  return match ? match[1] : data;
};
var usePollinationsText_default = usePollinationsText;

// node_modules/@pollinations/react/src/hooks/usePollinationsChat.js
var import_react3 = __toESM(require_react(), 1);
var usePollinationsChat = (initMessages = [], options = {}) => {
  const { seed = 42, jsonMode = false, model = "openai" } = options;
  const [messages, setMessages] = (0, import_react3.useState)(initMessages);
  const sendUserMessage = (0, import_react3.useCallback)((userMessage) => {
    const updatedMessages = [...messages, { role: "user", content: userMessage }];
    setMessages(updatedMessages);
    const requestBody = {
      messages: updatedMessages,
      jsonMode,
      seed,
      model
    };
    fetch(`https://text.pollinations.ai/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    }).then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.text();
    }).then((data) => {
      let assistantMessage;
      try {
        assistantMessage = jsonMode ? JSON.parse(data) : data;
      } catch (error) {
        console.error("Error parsing response:", error);
        assistantMessage = `Sorry, I encountered an error while processing the response: ${error.message}`;
      }
      setMessages((prevMessages) => [...prevMessages, { role: "assistant", content: assistantMessage }]);
    }).catch((error) => {
      console.error("Error fetching chat:", error);
      const errorMessage = `I'm sorry, but I encountered an error while trying to respond: ${error.message}. Please try again later.`;
      setMessages((prevMessages) => [...prevMessages, { role: "assistant", content: errorMessage }]);
    });
  }, [messages, jsonMode, seed, model]);
  return { sendUserMessage, messages };
};
var usePollinationsChat_default = usePollinationsChat;
export {
  usePollinationsChat_default as usePollinationsChat,
  usePollinationsImage_default as usePollinationsImage,
  usePollinationsText_default as usePollinationsText
};
//# sourceMappingURL=@pollinations_react.js.map
